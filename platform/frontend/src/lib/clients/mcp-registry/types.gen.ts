// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://registry.modelcontextprotocol.io' | (string & {});
};

export type Argument = {
    /**
     * A list of possible values for the input. If provided, the user must select one of these values.
     */
    choices?: Array<string> | null;
    /**
     * The default value for the input. This should be a valid value for the input. If you want to provide input examples or guidance, use the placeholder field instead.
     */
    default?: string;
    /**
     * A description of the input, which clients can use to provide context to the user.
     */
    description?: string;
    /**
     * Specifies the input format. Supported values include filepath, which should be interpreted as a file on the user's filesystem.
     */
    format?: 'string' | 'number' | 'boolean' | 'filepath';
    /**
     * Whether the argument can be repeated multiple times.
     */
    isRepeated?: boolean;
    /**
     * Whether the input is required
     */
    isRequired?: boolean;
    /**
     * Indicates whether the input is a secret value (e.g., password, token). If true, clients should handle the value securely.
     */
    isSecret?: boolean;
    /**
     * The flag name (for named arguments), including any leading dashes. Empty for positional arguments.
     */
    name?: string;
    /**
     * A placeholder for the input to be displaying during configuration. This is used to provide examples or guidance about the expected form or content of the input.
     */
    placeholder?: string;
    /**
     * Argument type: 'positional' or 'named'
     */
    type: string;
    /**
     * The value for the input. If this is not set, the user may be prompted to provide a value. Identifiers wrapped in {curly_braces} will be replaced with the corresponding properties from the input variables map.
     */
    value?: string;
    /**
     * An identifier for positional arguments. Used in transport URL variable substitution.
     */
    valueHint?: string;
    /**
     * A map of variable names to their values. Keys in the input value that are wrapped in {curly_braces} will be replaced with the corresponding variable values.
     */
    variables?: {
        [key: string]: Input;
    };
};

export type ErrorDetail = {
    /**
     * Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'
     */
    location?: string;
    /**
     * Error message text
     */
    message?: string;
    /**
     * The value at the given location
     */
    value?: unknown;
};

export type ErrorModel = {
    /**
     * A human-readable explanation specific to this occurrence of the problem.
     */
    detail?: string;
    /**
     * Optional list of individual error details
     */
    errors?: Array<ErrorDetail> | null;
    /**
     * A URI reference that identifies the specific occurrence of the problem.
     */
    instance?: string;
    /**
     * HTTP status code
     */
    status?: number;
    /**
     * A short, human-readable summary of the problem type. This value should not change between occurrences of the error.
     */
    title?: string;
    /**
     * A URI reference to human-readable documentation for the error.
     */
    type?: string;
};

export type GitHubOidcTokenExchangeInputBody = {
    /**
     * GitHub Actions OIDC token
     */
    oidc_token: string;
};

export type GitHubTokenExchangeInputBody = {
    /**
     * GitHub OAuth token
     */
    github_token: string;
};

export type HealthBody = {
    /**
     * GitHub OAuth App Client ID
     */
    github_client_id?: string;
    /**
     * Health status
     */
    status: string;
};

export type Icon = {
    /**
     * Optional MIME type override if the source MIME type is missing or generic. Must be one of: image/png, image/jpeg, image/jpg, image/svg+xml, image/webp.
     */
    mimeType?: 'image/png' | 'image/jpeg' | 'image/jpg' | 'image/svg+xml' | 'image/webp';
    /**
     * Optional array of strings that specify sizes at which the icon can be used. Each string should be in WxH format (e.g., '48x48', '96x96') or 'any' for scalable formats like SVG. If not provided, the client should assume that the icon can be used at any size.
     */
    sizes?: Array<string> | null;
    /**
     * A standard URI pointing to an icon resource. Must be an HTTPS URL. Consumers SHOULD take steps to ensure URLs serving icons are from the same domain as the server or a trusted domain. Consumers SHOULD take appropriate precautions when consuming SVGs as they can contain executable JavaScript.
     */
    src: string;
    /**
     * Optional specifier for the theme this icon is designed for. 'light' indicates the icon is designed to be used with a light background, and 'dark' indicates the icon is designed to be used with a dark background. If not provided, the client should assume the icon can be used with any theme.
     */
    theme?: 'light' | 'dark';
};

export type Input = {
    /**
     * A list of possible values for the input. If provided, the user must select one of these values.
     */
    choices?: Array<string> | null;
    /**
     * The default value for the input. This should be a valid value for the input. If you want to provide input examples or guidance, use the placeholder field instead.
     */
    default?: string;
    /**
     * A description of the input, which clients can use to provide context to the user.
     */
    description?: string;
    /**
     * Specifies the input format. Supported values include filepath, which should be interpreted as a file on the user's filesystem.
     */
    format?: 'string' | 'number' | 'boolean' | 'filepath';
    /**
     * Whether the input is required
     */
    isRequired?: boolean;
    /**
     * Indicates whether the input is a secret value (e.g., password, token). If true, clients should handle the value securely.
     */
    isSecret?: boolean;
    /**
     * A placeholder for the input to be displaying during configuration. This is used to provide examples or guidance about the expected form or content of the input.
     */
    placeholder?: string;
    /**
     * The value for the input. If this is not set, the user may be prompted to provide a value. Identifiers wrapped in {curly_braces} will be replaced with the corresponding properties from the input variables map.
     */
    value?: string;
};

export type KeyValueInput = {
    /**
     * A list of possible values for the input. If provided, the user must select one of these values.
     */
    choices?: Array<string> | null;
    /**
     * The default value for the input. This should be a valid value for the input. If you want to provide input examples or guidance, use the placeholder field instead.
     */
    default?: string;
    /**
     * A description of the input, which clients can use to provide context to the user.
     */
    description?: string;
    /**
     * Specifies the input format. Supported values include filepath, which should be interpreted as a file on the user's filesystem.
     */
    format?: 'string' | 'number' | 'boolean' | 'filepath';
    /**
     * Whether the input is required
     */
    isRequired?: boolean;
    /**
     * Indicates whether the input is a secret value (e.g., password, token). If true, clients should handle the value securely.
     */
    isSecret?: boolean;
    /**
     * Name of the header or environment variable.
     */
    name: string;
    /**
     * A placeholder for the input to be displaying during configuration. This is used to provide examples or guidance about the expected form or content of the input.
     */
    placeholder?: string;
    /**
     * The value for the input. If this is not set, the user may be prompted to provide a value. Identifiers wrapped in {curly_braces} will be replaced with the corresponding properties from the input variables map.
     */
    value?: string;
    /**
     * A map of variable names to their values. Keys in the input value that are wrapped in {curly_braces} will be replaced with the corresponding variable values.
     */
    variables?: {
        [key: string]: Input;
    };
};

export type Metadata = {
    /**
     * Number of items in current page
     */
    count: number;
    /**
     * Pagination cursor for retrieving the next page of results. Use this exact value in the cursor query parameter of your next request.
     */
    nextCursor?: string;
};

export type OidcTokenExchangeInputBody = {
    /**
     * OIDC ID token from any provider
     */
    oidc_token: string;
};

export type Package = {
    /**
     * A mapping of environment variables to be set when running the package.
     */
    environmentVariables?: Array<KeyValueInput> | null;
    /**
     * SHA-256 hash of the package file for integrity verification. Required for MCPB packages and optional for other package types. Authors are responsible for generating correct SHA-256 hashes when creating server.json. If present, MCP clients must validate the downloaded file matches the hash before running packages to ensure file integrity.
     */
    fileSha256?: string;
    /**
     * Package identifier - either a package name (for registries) or URL (for direct downloads)
     */
    identifier: string;
    /**
     * A list of arguments to be passed to the package's binary.
     */
    packageArguments?: Array<Argument> | null;
    /**
     * Base URL of the package registry
     */
    registryBaseUrl?: string;
    /**
     * Registry type indicating how to download packages (e.g., 'npm', 'pypi', 'oci', 'nuget', 'mcpb')
     */
    registryType: string;
    /**
     * A list of arguments to be passed to the package's runtime command (such as docker or npx). The runtimeHint field should be provided when runtimeArguments are present.
     */
    runtimeArguments?: Array<Argument> | null;
    /**
     * A hint to help clients determine the appropriate runtime for the package. This field should be provided when runtimeArguments are present.
     */
    runtimeHint?: string;
    /**
     * Transport protocol configuration for the package
     */
    transport: Transport;
    /**
     * Package version. Must be a specific version. Version ranges are rejected (e.g., '^1.2.3', '~1.2.3', '>=1.2.3', '1.x', '1.*').
     */
    version?: string;
};

export type PingBody = {
    /**
     * Ping response
     */
    pong: boolean;
};

export type RegistryExtensions = {
    /**
     * Whether this is the latest version of the server
     */
    isLatest: boolean;
    /**
     * Timestamp when the server was first published to the registry
     */
    publishedAt: string;
    /**
     * Server lifecycle status
     */
    status: 'active' | 'deprecated' | 'deleted';
    /**
     * Timestamp when the server entry was last updated
     */
    updatedAt?: string;
};

export type Repository = {
    /**
     * Repository identifier from the hosting service (e.g., GitHub repo ID). Owned and determined by the source forge. Should remain stable across repository renames and may be used to detect repository resurrection attacks - if a repository is deleted and recreated, the ID should change. For GitHub, use: gh api repos/<owner>/<repo> --jq '.id'
     */
    id?: string;
    /**
     * Repository hosting service identifier. Used by registries to determine validation and API access methods.
     */
    source: string;
    /**
     * Optional relative path from repository root to the server location within a monorepo or nested package structure. Must be a clean relative path.
     */
    subfolder?: string;
    /**
     * Repository URL for browsing source code. Should support both web browsing and git clone operations.
     */
    url: string;
};

export type ResponseMeta = {
    /**
     * Official MCP registry metadata
     */
    'io.modelcontextprotocol.registry/official'?: RegistryExtensions;
};

export type ServerJson = {
    /**
     * JSON Schema URI for this server.json format
     */
    $schema: string;
    /**
     * Extension metadata using reverse DNS namespacing for vendor-specific data
     */
    _meta?: ServerMeta;
    /**
     * Clear human-readable explanation of server functionality.
     */
    description: string;
    /**
     * Optional set of sized icons that the client can display in a user interface.
     */
    icons?: Array<Icon> | null;
    /**
     * Server name in reverse-DNS format. Must contain exactly one forward slash separating namespace from server name.
     */
    name: string;
    /**
     * Array of package configurations
     */
    packages?: Array<Package> | null;
    /**
     * Array of remote configurations
     */
    remotes?: Array<Transport> | null;
    /**
     * Optional repository metadata for the MCP server source code.
     */
    repository?: Repository;
    /**
     * Optional human-readable title or display name for the MCP server.
     */
    title?: string;
    /**
     * Version string for this server. SHOULD follow semantic versioning.
     */
    version: string;
    /**
     * Optional URL to the server's homepage, documentation, or project website.
     */
    websiteUrl?: string;
};

export type ServerListResponse = {
    /**
     * Pagination metadata
     */
    metadata: Metadata;
    /**
     * List of server entries
     */
    servers: Array<ServerResponse> | null;
};

export type ServerMeta = {
    /**
     * Publisher-provided metadata for downstream registries
     */
    'io.modelcontextprotocol.registry/publisher-provided'?: {
        [key: string]: unknown;
    };
};

export type ServerResponse = {
    /**
     * Registry-managed metadata
     */
    _meta: ResponseMeta;
    /**
     * Server configuration and metadata
     */
    server: ServerJson;
};

export type SignatureTokenExchangeInput = {
    /**
     * Domain name
     */
    domain: string;
    /**
     * Hex-encoded Ed25519 signature of timestamp
     */
    signed_timestamp: string;
    /**
     * RFC3339 timestamp
     */
    timestamp: string;
};

export type TokenResponse = {
    expires_at: number;
    registry_token: string;
};

export type Transport = {
    /**
     * HTTP headers for streamable-http or sse transports
     */
    headers?: Array<KeyValueInput> | null;
    /**
     * Transport type (stdio, streamable-http, or sse)
     */
    type: string;
    /**
     * URL for streamable-http or sse transports
     */
    url?: string;
};

export type VersionBody = {
    /**
     * Build timestamp
     */
    build_time: string;
    /**
     * Git commit SHA
     */
    git_commit: string;
    /**
     * Application version
     */
    version: string;
};

export type ExchangeDnsTokenV01Data = {
    body: SignatureTokenExchangeInput;
    path?: never;
    query?: never;
    url: '/v0.1/auth/dns';
};

export type ExchangeDnsTokenV01Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ExchangeDnsTokenV01Error = ExchangeDnsTokenV01Errors[keyof ExchangeDnsTokenV01Errors];

export type ExchangeDnsTokenV01Responses = {
    /**
     * OK
     */
    200: TokenResponse;
};

export type ExchangeDnsTokenV01Response = ExchangeDnsTokenV01Responses[keyof ExchangeDnsTokenV01Responses];

export type ExchangeGithubTokenV01Data = {
    body: GitHubTokenExchangeInputBody;
    path?: never;
    query?: never;
    url: '/v0.1/auth/github-at';
};

export type ExchangeGithubTokenV01Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ExchangeGithubTokenV01Error = ExchangeGithubTokenV01Errors[keyof ExchangeGithubTokenV01Errors];

export type ExchangeGithubTokenV01Responses = {
    /**
     * OK
     */
    200: TokenResponse;
};

export type ExchangeGithubTokenV01Response = ExchangeGithubTokenV01Responses[keyof ExchangeGithubTokenV01Responses];

export type ExchangeGithubOidcTokenV01Data = {
    body: GitHubOidcTokenExchangeInputBody;
    path?: never;
    query?: never;
    url: '/v0.1/auth/github-oidc';
};

export type ExchangeGithubOidcTokenV01Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ExchangeGithubOidcTokenV01Error = ExchangeGithubOidcTokenV01Errors[keyof ExchangeGithubOidcTokenV01Errors];

export type ExchangeGithubOidcTokenV01Responses = {
    /**
     * OK
     */
    200: TokenResponse;
};

export type ExchangeGithubOidcTokenV01Response = ExchangeGithubOidcTokenV01Responses[keyof ExchangeGithubOidcTokenV01Responses];

export type ExchangeHttpTokenV01Data = {
    body: SignatureTokenExchangeInput;
    path?: never;
    query?: never;
    url: '/v0.1/auth/http';
};

export type ExchangeHttpTokenV01Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ExchangeHttpTokenV01Error = ExchangeHttpTokenV01Errors[keyof ExchangeHttpTokenV01Errors];

export type ExchangeHttpTokenV01Responses = {
    /**
     * OK
     */
    200: TokenResponse;
};

export type ExchangeHttpTokenV01Response = ExchangeHttpTokenV01Responses[keyof ExchangeHttpTokenV01Responses];

export type ExchangeOidcTokenV01Data = {
    body: OidcTokenExchangeInputBody;
    path?: never;
    query?: never;
    url: '/v0.1/auth/oidc';
};

export type ExchangeOidcTokenV01Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ExchangeOidcTokenV01Error = ExchangeOidcTokenV01Errors[keyof ExchangeOidcTokenV01Errors];

export type ExchangeOidcTokenV01Responses = {
    /**
     * OK
     */
    200: TokenResponse;
};

export type ExchangeOidcTokenV01Response = ExchangeOidcTokenV01Responses[keyof ExchangeOidcTokenV01Responses];

export type GetHealthV01Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v0.1/health';
};

export type GetHealthV01Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetHealthV01Error = GetHealthV01Errors[keyof GetHealthV01Errors];

export type GetHealthV01Responses = {
    /**
     * OK
     */
    200: HealthBody;
};

export type GetHealthV01Response = GetHealthV01Responses[keyof GetHealthV01Responses];

export type PingV01Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v0.1/ping';
};

export type PingV01Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type PingV01Error = PingV01Errors[keyof PingV01Errors];

export type PingV01Responses = {
    /**
     * OK
     */
    200: PingBody;
};

export type PingV01Response = PingV01Responses[keyof PingV01Responses];

export type PublishServerV01Data = {
    body: ServerJson;
    headers: {
        /**
         * Registry JWT token (obtained from /v0/auth/token/github)
         */
        Authorization: string;
    };
    path?: never;
    query?: never;
    url: '/v0.1/publish';
};

export type PublishServerV01Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type PublishServerV01Error = PublishServerV01Errors[keyof PublishServerV01Errors];

export type PublishServerV01Responses = {
    /**
     * OK
     */
    200: ServerResponse;
};

export type PublishServerV01Response = PublishServerV01Responses[keyof PublishServerV01Responses];

export type ListServersV01Data = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Pagination cursor
         */
        cursor?: string;
        /**
         * Number of items per page
         */
        limit?: number;
        /**
         * Filter servers updated since timestamp (RFC3339 datetime)
         */
        updated_since?: string;
        /**
         * Search servers by name (substring match)
         */
        search?: string;
        /**
         * Filter by version ('latest' for latest version, or an exact version like '1.2.3')
         */
        version?: string;
    };
    url: '/v0.1/servers';
};

export type ListServersV01Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ListServersV01Error = ListServersV01Errors[keyof ListServersV01Errors];

export type ListServersV01Responses = {
    /**
     * OK
     */
    200: ServerListResponse;
};

export type ListServersV01Response = ListServersV01Responses[keyof ListServersV01Responses];

export type GetServerVersionsV01Data = {
    body?: never;
    path: {
        /**
         * URL-encoded server name
         */
        serverName: string;
    };
    query?: never;
    url: '/v0.1/servers/{serverName}/versions';
};

export type GetServerVersionsV01Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetServerVersionsV01Error = GetServerVersionsV01Errors[keyof GetServerVersionsV01Errors];

export type GetServerVersionsV01Responses = {
    /**
     * OK
     */
    200: ServerListResponse;
};

export type GetServerVersionsV01Response = GetServerVersionsV01Responses[keyof GetServerVersionsV01Responses];

export type GetServerVersionV01Data = {
    body?: never;
    path: {
        /**
         * URL-encoded server name
         */
        serverName: string;
        /**
         * URL-encoded server version
         */
        version: string;
    };
    query?: never;
    url: '/v0.1/servers/{serverName}/versions/{version}';
};

export type GetServerVersionV01Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetServerVersionV01Error = GetServerVersionV01Errors[keyof GetServerVersionV01Errors];

export type GetServerVersionV01Responses = {
    /**
     * OK
     */
    200: ServerResponse;
};

export type GetServerVersionV01Response = GetServerVersionV01Responses[keyof GetServerVersionV01Responses];

export type EditServerV01Data = {
    body: ServerJson;
    headers: {
        /**
         * Registry JWT token with edit permissions
         */
        Authorization: string;
    };
    path: {
        /**
         * URL-encoded server name
         */
        serverName: string;
        /**
         * URL-encoded version to edit
         */
        version: string;
    };
    query?: {
        /**
         * New status for the server (active, deprecated, deleted)
         */
        status?: 'active' | 'deprecated' | 'deleted';
    };
    url: '/v0.1/servers/{serverName}/versions/{version}';
};

export type EditServerV01Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type EditServerV01Error = EditServerV01Errors[keyof EditServerV01Errors];

export type EditServerV01Responses = {
    /**
     * OK
     */
    200: ServerResponse;
};

export type EditServerV01Response = EditServerV01Responses[keyof EditServerV01Responses];

export type GetVersionV01Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v0.1/version';
};

export type GetVersionV01Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetVersionV01Error = GetVersionV01Errors[keyof GetVersionV01Errors];

export type GetVersionV01Responses = {
    /**
     * OK
     */
    200: VersionBody;
};

export type GetVersionV01Response = GetVersionV01Responses[keyof GetVersionV01Responses];

export type ExchangeDnsTokenV0Data = {
    body: SignatureTokenExchangeInput;
    path?: never;
    query?: never;
    url: '/v0/auth/dns';
};

export type ExchangeDnsTokenV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ExchangeDnsTokenV0Error = ExchangeDnsTokenV0Errors[keyof ExchangeDnsTokenV0Errors];

export type ExchangeDnsTokenV0Responses = {
    /**
     * OK
     */
    200: TokenResponse;
};

export type ExchangeDnsTokenV0Response = ExchangeDnsTokenV0Responses[keyof ExchangeDnsTokenV0Responses];

export type ExchangeGithubTokenV0Data = {
    body: GitHubTokenExchangeInputBody;
    path?: never;
    query?: never;
    url: '/v0/auth/github-at';
};

export type ExchangeGithubTokenV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ExchangeGithubTokenV0Error = ExchangeGithubTokenV0Errors[keyof ExchangeGithubTokenV0Errors];

export type ExchangeGithubTokenV0Responses = {
    /**
     * OK
     */
    200: TokenResponse;
};

export type ExchangeGithubTokenV0Response = ExchangeGithubTokenV0Responses[keyof ExchangeGithubTokenV0Responses];

export type ExchangeGithubOidcTokenV0Data = {
    body: GitHubOidcTokenExchangeInputBody;
    path?: never;
    query?: never;
    url: '/v0/auth/github-oidc';
};

export type ExchangeGithubOidcTokenV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ExchangeGithubOidcTokenV0Error = ExchangeGithubOidcTokenV0Errors[keyof ExchangeGithubOidcTokenV0Errors];

export type ExchangeGithubOidcTokenV0Responses = {
    /**
     * OK
     */
    200: TokenResponse;
};

export type ExchangeGithubOidcTokenV0Response = ExchangeGithubOidcTokenV0Responses[keyof ExchangeGithubOidcTokenV0Responses];

export type ExchangeHttpTokenV0Data = {
    body: SignatureTokenExchangeInput;
    path?: never;
    query?: never;
    url: '/v0/auth/http';
};

export type ExchangeHttpTokenV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ExchangeHttpTokenV0Error = ExchangeHttpTokenV0Errors[keyof ExchangeHttpTokenV0Errors];

export type ExchangeHttpTokenV0Responses = {
    /**
     * OK
     */
    200: TokenResponse;
};

export type ExchangeHttpTokenV0Response = ExchangeHttpTokenV0Responses[keyof ExchangeHttpTokenV0Responses];

export type ExchangeOidcTokenV0Data = {
    body: OidcTokenExchangeInputBody;
    path?: never;
    query?: never;
    url: '/v0/auth/oidc';
};

export type ExchangeOidcTokenV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ExchangeOidcTokenV0Error = ExchangeOidcTokenV0Errors[keyof ExchangeOidcTokenV0Errors];

export type ExchangeOidcTokenV0Responses = {
    /**
     * OK
     */
    200: TokenResponse;
};

export type ExchangeOidcTokenV0Response = ExchangeOidcTokenV0Responses[keyof ExchangeOidcTokenV0Responses];

export type GetHealthV0Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v0/health';
};

export type GetHealthV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetHealthV0Error = GetHealthV0Errors[keyof GetHealthV0Errors];

export type GetHealthV0Responses = {
    /**
     * OK
     */
    200: HealthBody;
};

export type GetHealthV0Response = GetHealthV0Responses[keyof GetHealthV0Responses];

export type PingV0Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v0/ping';
};

export type PingV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type PingV0Error = PingV0Errors[keyof PingV0Errors];

export type PingV0Responses = {
    /**
     * OK
     */
    200: PingBody;
};

export type PingV0Response = PingV0Responses[keyof PingV0Responses];

export type PublishServerV0Data = {
    body: ServerJson;
    headers: {
        /**
         * Registry JWT token (obtained from /v0/auth/token/github)
         */
        Authorization: string;
    };
    path?: never;
    query?: never;
    url: '/v0/publish';
};

export type PublishServerV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type PublishServerV0Error = PublishServerV0Errors[keyof PublishServerV0Errors];

export type PublishServerV0Responses = {
    /**
     * OK
     */
    200: ServerResponse;
};

export type PublishServerV0Response = PublishServerV0Responses[keyof PublishServerV0Responses];

export type ListServersV0Data = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Pagination cursor
         */
        cursor?: string;
        /**
         * Number of items per page
         */
        limit?: number;
        /**
         * Filter servers updated since timestamp (RFC3339 datetime)
         */
        updated_since?: string;
        /**
         * Search servers by name (substring match)
         */
        search?: string;
        /**
         * Filter by version ('latest' for latest version, or an exact version like '1.2.3')
         */
        version?: string;
    };
    url: '/v0/servers';
};

export type ListServersV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type ListServersV0Error = ListServersV0Errors[keyof ListServersV0Errors];

export type ListServersV0Responses = {
    /**
     * OK
     */
    200: ServerListResponse;
};

export type ListServersV0Response = ListServersV0Responses[keyof ListServersV0Responses];

export type GetServerVersionsV0Data = {
    body?: never;
    path: {
        /**
         * URL-encoded server name
         */
        serverName: string;
    };
    query?: never;
    url: '/v0/servers/{serverName}/versions';
};

export type GetServerVersionsV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetServerVersionsV0Error = GetServerVersionsV0Errors[keyof GetServerVersionsV0Errors];

export type GetServerVersionsV0Responses = {
    /**
     * OK
     */
    200: ServerListResponse;
};

export type GetServerVersionsV0Response = GetServerVersionsV0Responses[keyof GetServerVersionsV0Responses];

export type GetServerVersionV0Data = {
    body?: never;
    path: {
        /**
         * URL-encoded server name
         */
        serverName: string;
        /**
         * URL-encoded server version
         */
        version: string;
    };
    query?: never;
    url: '/v0/servers/{serverName}/versions/{version}';
};

export type GetServerVersionV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetServerVersionV0Error = GetServerVersionV0Errors[keyof GetServerVersionV0Errors];

export type GetServerVersionV0Responses = {
    /**
     * OK
     */
    200: ServerResponse;
};

export type GetServerVersionV0Response = GetServerVersionV0Responses[keyof GetServerVersionV0Responses];

export type EditServerV0Data = {
    body: ServerJson;
    headers: {
        /**
         * Registry JWT token with edit permissions
         */
        Authorization: string;
    };
    path: {
        /**
         * URL-encoded server name
         */
        serverName: string;
        /**
         * URL-encoded version to edit
         */
        version: string;
    };
    query?: {
        /**
         * New status for the server (active, deprecated, deleted)
         */
        status?: 'active' | 'deprecated' | 'deleted';
    };
    url: '/v0/servers/{serverName}/versions/{version}';
};

export type EditServerV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type EditServerV0Error = EditServerV0Errors[keyof EditServerV0Errors];

export type EditServerV0Responses = {
    /**
     * OK
     */
    200: ServerResponse;
};

export type EditServerV0Response = EditServerV0Responses[keyof EditServerV0Responses];

export type GetVersionV0Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v0/version';
};

export type GetVersionV0Errors = {
    /**
     * Error
     */
    default: ErrorModel;
};

export type GetVersionV0Error = GetVersionV0Errors[keyof GetVersionV0Errors];

export type GetVersionV0Responses = {
    /**
     * OK
     */
    200: VersionBody;
};

export type GetVersionV0Response = GetVersionV0Responses[keyof GetVersionV0Responses];
